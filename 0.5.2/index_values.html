<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BottomUp" rel="Chapter" href="BottomUp.html">
<link title="TopDown" rel="Chapter" href="TopDown.html">
<link title="Default" rel="Chapter" href="Default.html">
<link title="BottomUpAst" rel="Chapter" href="BottomUpAst.html">
<link title="BottomUpParser" rel="Chapter" href="BottomUpParser.html">
<link title="BottomUpLexer" rel="Chapter" href="BottomUpLexer.html">
<link title="TopDownParser" rel="Chapter" href="TopDownParser.html">
<link title="TopDownLexer" rel="Chapter" href="TopDownLexer.html">
<link title="TopDownAst" rel="Chapter" href="TopDownAst.html">
<link title="Version" rel="Chapter" href="Version.html">
<link title="TopDownUnix" rel="Chapter" href="TopDownUnix.html">
<link title="CamlInterface" rel="Chapter" href="CamlInterface.html"><title>Index of values</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Index of values</h1>
<table>
<tr><td align="left"><div></div></td></tr>
<tr><td><a href="TopDownLexer.html#VAL__ocaml_lex_tables">__ocaml_lex_tables</a> [<a href="TopDownLexer.html">TopDownLexer</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUpLexer.html#VAL__ocaml_lex_tables">__ocaml_lex_tables</a> [<a href="BottomUpLexer.html">BottomUpLexer</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownLexer.html#VAL__ocaml_lex_token_rec">__ocaml_lex_token_rec</a> [<a href="TopDownLexer.html">TopDownLexer</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUpLexer.html#VAL__ocaml_lex_token_rec">__ocaml_lex_token_rec</a> [<a href="BottomUpLexer.html">BottomUpLexer</a>]</td>
<td></td></tr>
<tr><td align="left"><div>A</div></td></tr>
<tr><td><a href="TopDown.S.Rewriting.html#VALadd">add</a> [<a href="TopDown.S.Rewriting.html">TopDown.S.Rewriting</a>]</td>
<td><div class="info">
<p>Add a rule to the system</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Index.html#VALadd">add</a> [<a href="TopDown.S.Index.html">TopDown.S.Index</a>]</td>
<td><div class="info">
<p>Add the term-&gt;data binding.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.BuiltinFun.html#VALadd">add</a> [<a href="TopDown.S.BuiltinFun.html">TopDown.S.BuiltinFun</a>]</td>
<td><div class="info">
<p>Interpret the given constant by the given function.</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.html#VALadd_builtin">add_builtin</a> [<a href="CamlInterface.html">CamlInterface</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALadd_builtin">add_builtin</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td><div class="info">
<p>Add a builtin fun</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.DB.html#VALadd_clause">add_clause</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALadd_clauses">add_clauses</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALadd_fact">add_fact</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALadd_facts">add_facts</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALadd_list">add_list</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALadd_list">add_list</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td><div class="info">
<p>Add given list of axioms</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALadd_list">add_list</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td><div class="info">
<p>Add given list of axioms</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Rewriting.html#VALadd_list">add_list</a> [<a href="TopDown.S.Rewriting.html">TopDown.S.Rewriting</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.BuiltinFun.html#VALadd_list">add_list</a> [<a href="TopDown.S.BuiltinFun.html">TopDown.S.BuiltinFun</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.html#VALalpha_equiv">alpha_equiv</a> [<a href="TopDown.S.html">TopDown.S</a>]</td>
<td><div class="info">
<p>Test for alpha equivalence.</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALapply">apply</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALapply">apply</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALapply">apply</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td><div class="info">
<p>apply the relation symbol to some term</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.html#VALare_alpha_equiv">are_alpha_equiv</a> [<a href="TopDown.S.html">TopDown.S</a>]</td>
<td><div class="info">
<p>Special version of <code class="code">alpha_equiv</code>, using distinct scopes for the two
        terms to test, and discarding the result</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALarity">arity</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Number of subliterals of the literal.</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALarray">array</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.html#VALask">ask</a> [<a href="TopDown.S.html">TopDown.S</a>]</td>
<td><div class="info">
<p>Returns the answers to a query in a given DB.</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.Query.html#VALask">ask</a> [<a href="BottomUp.S.Query.html">BottomUp.S.Query</a>]</td>
<td><div class="info">
<p>Given a list of variables, and a list of literals that contain those
          variables, return a set.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.html#VALask_lits">ask_lits</a> [<a href="TopDown.S.html">TopDown.S</a>]</td>
<td><div class="info">
<p>Extension of <a href="TopDown.S.html#VALask"><code class="code">TopDown.S.ask</code></a>, where the query ranges over the list of
        variables (the term list), all of which must be bound in
        the list of literals that form a constraint.</p>

</div>
</td></tr>
<tr><td align="left"><div>B</div></td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALbind">bind</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td><div class="info">
<p>Bind a variable,scope to a term,scope</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALbool">bool</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.Default.html#VALbuiltin">builtin</a> [<a href="TopDown.Default.html">TopDown.Default</a>]</td>
<td><div class="info">
<p>Default builtin functions</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.DB.html#VALbuiltin_funs">builtin_funs</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td align="left"><div>C</div></td></tr>
<tr><td><a href="BottomUp.S.Query.html#VALcardinal">cardinal</a> [<a href="BottomUp.S.Query.html">BottomUp.S.Query</a>]</td>
<td><div class="info">
<p>Number of elements of the set</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALcheck_safe">check_safe</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>A datalog clause is safe iff all variables in its head also occur in its body</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.html#VALclause_are_alpha_equiv">clause_are_alpha_equiv</a> [<a href="TopDown.S.html">TopDown.S</a>]</td>
<td><div class="info">
<p>Alpha equivalence of clauses.</p>

</div>
</td></tr>
<tr><td><a href="Default.html#VALclause_of_ast">clause_of_ast</a> [<a href="Default.html">Default</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSE.html#VALclause_of_ast">clause_of_ast</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSE.html#VALclause_of_string">clause_of_string</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td><div class="info">
<p>Parse a clause from a string, or fail.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.PARSE.html#VALclauses_of_ast">clauses_of_ast</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALclear">clear</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Index.html#VALclear">clear</a> [<a href="TopDown.S.Index.html">TopDown.S.Index</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALcompatible">compatible</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.Univ.html#VALcompatible">compatible</a> [<a href="BottomUp.Univ.html">BottomUp.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALcopy">copy</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Rewriting.html#VALcopy">copy</a> [<a href="TopDown.S.Rewriting.html">TopDown.S.Rewriting</a>]</td>
<td><div class="info">
<p>Copy the rewriting system</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Index.html#VALcopy">copy</a> [<a href="TopDown.S.Index.html">TopDown.S.Index</a>]</td>
<td><div class="info">
<p>Recursive copy of the index</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.RelList.html#VALcreate">create</a> [<a href="CamlInterface.RelList.html">CamlInterface.RelList</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALcreate">create</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALcreate">create</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALcreate">create</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td><div class="info">
<p>New relation, with given name and argument</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.DB.html#VALcreate">create</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Rewriting.html#VALcreate">create</a> [<a href="TopDown.S.Rewriting.html">TopDown.S.Rewriting</a>]</td>
<td><div class="info">
<p>New rewriting system</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.BuiltinFun.html#VALcreate">create</a> [<a href="TopDown.S.BuiltinFun.html">TopDown.S.BuiltinFun</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSE.html#VALcreate_ctx">create_ctx</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALcreate_renaming">create_renaming</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td></td></tr>
<tr><td align="left"><div>D</div></td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_add">db_add</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Add the clause/fact to the DB as an axiom, updating fixpoint.</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_add_fact">db_add_fact</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Add a fact (ground unit clause)</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_add_fun">db_add_fun</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Add a function to be called on new literals.</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_copy">db_copy</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Deep copy of the DB</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_create">db_create</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Create a DB</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_explain">db_explain</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Explain the given fact by returning a list of facts that imply it
        under the current clauses, or raise Not_found</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_explanations">db_explanations</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Get all the explanations that explain why this clause is true</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_fold">db_fold</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Fold on all clauses in the current DB (including fixpoint)</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_goal">db_goal</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Add a goal to the DB.</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_goals">db_goals</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Iterate on all current goals</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_match">db_match</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>match the given literal with facts of the DB, calling the handler on
        each fact that match</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_mem">db_mem</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Is the clause member of the DB?</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_premises">db_premises</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Immediate premises of the fact (ie the facts that resolved with
        a clause to give the literal), plus the clause that has been used.</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_query">db_query</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Like <a href="BottomUp.S.html#VALdb_match"><code class="code">BottomUp.S.db_match</code></a>, but the additional int list is used to select
        bindings of variables in the literal.</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_size">db_size</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Size of the DB</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_subscribe_all_facts">db_subscribe_all_facts</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_subscribe_fact">db_subscribe_fact</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALdb_subscribe_goal">db_subscribe_goal</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.Default.html#VALdefault_interpreters">default_interpreters</a> [<a href="TopDown.Default.html">TopDown.Default</a>]</td>
<td><div class="info">
<p>List of default interpreters for some symbols, mostly
        infix predicates</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALderef">deref</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td><div class="info">
<p>While the term is a variable bound in subst, follow its binding.</p>

</div>
</td></tr>
<tr><td align="left"><div>E</div></td></tr>
<tr><td><a href="BottomUp.Univ.html#VALembed">embed</a> [<a href="BottomUp.Univ.html">BottomUp.Univ</a>]</td>
<td><div class="info">
<p>Create a new embedding.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Index.html#VALempty">empty</a> [<a href="TopDown.S.Index.html">TopDown.S.Index</a>]</td>
<td><div class="info">
<p>new, empty index</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALempty">empty</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td><div class="info">
<p>Empty subst</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALeq">eq</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.C.html#VALeq">eq</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALeq">eq</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALeq">eq</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALeq_clause">eq_clause</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Check whether clauses are (syntactically) equal</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALeq_literal">eq_literal</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Are the literals equal?</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALeq_term">eq_term</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.CONST.html#VALequal">equal</a> [<a href="TopDown.CONST.html">TopDown.CONST</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownAst.html#VALerror_to_string">error_to_string</a> [<a href="TopDownAst.html">TopDownAst</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALeval">eval</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td><div class="info">
<p>Evaluate the given term at root</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.BuiltinFun.html#VALeval">eval</a> [<a href="TopDown.S.BuiltinFun.html">TopDown.S.BuiltinFun</a>]</td>
<td><div class="info">
<p>Evaluate the term at root</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALeval">eval</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td><div class="info">
<p>Apply the substitution to the term.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALeval_clause">eval_clause</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALeval_lit">eval_lit</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALeval_lits">eval_lits</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td></td></tr>
<tr><td align="left"><div>F</div></td></tr>
<tr><td><a href="TopDownLexer.html#VALfail">fail</a> [<a href="TopDownLexer.html">TopDownLexer</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALfind">find</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALfind">find</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALfind">find</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td><div class="info">
<p>Iterate on all instances of the relation present in the DB</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.DB.html#VALfind_clauses_head">find_clauses_head</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td><div class="info">
<p>find clauses whose head unifies with the given term,
          and give them along with the unifier, to the callback</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.DB.html#VALfind_facts">find_facts</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td><div class="info">
<p>find facts unifying with the given term, and give them
          along with the unifier, to the callback</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.DB.html#VALfind_interpretation">find_interpretation</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td><div class="info">
<p>Given an interpreted goal, try all interpreters on it,
          and match the query against their heads.</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALfloat">float</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.C.html#VALfmap">fmap</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALfmap">fmap</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALfmt">fmt</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALfmt">fmt</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALfmt">fmt</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.C.html#VALfmt">fmt</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALfmt">fmt</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALfmt">fmt</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALfrom_fun">from_fun</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALfrom_fun">from_fun</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td><div class="info">
<p>The given function decides of the given relation (if it
        returns true for a couple of constants, then the relation
        holds for those constants)</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALfrom_fun">from_fun</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td><div class="info">
<p>The given function decides of the given relation (if it returns true
        for a constant, then the relation holds for this constant)</p>

</div>
</td></tr>
<tr><td align="left"><div>G</div></td></tr>
<tr><td><a href="TopDown.S.Index.html#VALgeneralizations">generalizations</a> [<a href="TopDown.S.Index.html">TopDown.S.Index</a>]</td>
<td><div class="info">
<p>Retrieve data associated with terms that are a generalization
          of the given query term</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.RelList.html#VALget">get</a> [<a href="CamlInterface.RelList.html">CamlInterface.RelList</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALget">get</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALget">get</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALget">get</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td><div class="info">
<p>Check whether this term is a "R(t)" with <code class="code">t</code> an object packed
        with the appropriate key, and "R" the name of the given relation</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.T.html#VALground">ground</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td align="left"><div>H</div></td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALhash">hash</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.C.html#VALhash">hash</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALhash">hash</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALhash">hash</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.CONST.html#VALhash">hash</a> [<a href="TopDown.CONST.html">TopDown.CONST</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALhash_clause">hash_clause</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Hash the clause</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALhash_literal">hash_literal</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Hash the literal</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.C.html#VALhead_symbol">head_symbol</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALhead_symbol">head_symbol</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALhelp">help</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td><div class="info">
<p>Help messages for interpreted predicates</p>

</div>
</td></tr>
<tr><td align="left"><div>I</div></td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALint">int</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALinterpret">interpret</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td><div class="info">
<p>Add an interpreter for the given constant.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.DB.html#VALinterpret_list">interpret_list</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td><div class="info">
<p>Add several interpreters, with their documentation</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.BuiltinFun.html#VALinterpreted">interpreted</a> [<a href="TopDown.S.BuiltinFun.html">TopDown.S.BuiltinFun</a>]</td>
<td><div class="info">
<p>Is the constant interpreted by a built-in function?</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.T.html#VALis_apply">is_apply</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALis_const">is_const</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALis_fact">is_fact</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>A fact is a ground clause with empty body</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALis_ground">is_ground</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Is the literal ground (a fact)?</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.DB.html#VALis_interpreted">is_interpreted</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td><div class="info">
<p>Is the constant interpreted by some OCaml code?</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.T.html#VALis_var">is_var</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Index.html#VALiter">iter</a> [<a href="TopDown.S.Index.html">TopDown.S.Index</a>]</td>
<td><div class="info">
<p>Iterate on bindings</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.Query.html#VALiter">iter</a> [<a href="BottomUp.S.Query.html">BottomUp.S.Query</a>]</td>
<td><div class="info">
<p>Evaluate the set by iterating on it</p>

</div>
</td></tr>
<tr><td align="left"><div>L</div></td></tr>
<tr><td><a href="BottomUpLexer.html#VALlexing_error">lexing_error</a> [<a href="BottomUpLexer.html">BottomUpLexer</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALlist">list</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSE.html#VALlit_of_ast">lit_of_ast</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td></td></tr>
<tr><td><a href="Default.html#VALliteral_of_ast">literal_of_ast</a> [<a href="Default.html">Default</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Parse.html#VALload_chan">load_chan</a> [<a href="CamlInterface.Parse.html">CamlInterface.Parse</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Parse.html#VALload_file">load_file</a> [<a href="CamlInterface.Parse.html">CamlInterface.Parse</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Parse.html#VALload_string">load_string</a> [<a href="CamlInterface.Parse.html">CamlInterface.Parse</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownAst.html#VALloc_to_str">loc_to_str</a> [<a href="TopDownAst.html">TopDownAst</a>]</td>
<td></td></tr>
<tr><td align="left"><div>M</div></td></tr>
<tr><td><a href="CamlInterface.RelList.html#VALmake">make</a> [<a href="CamlInterface.RelList.html">CamlInterface.RelList</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALmake">make</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALmake">make</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALmake">make</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td><div class="info">
<p>Create a term from this relation description</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.Hashcons.html#VALmake">make</a> [<a href="BottomUp.Hashcons.html">BottomUp.Hashcons</a>]</td>
<td><div class="info">
<p>Hashcons the symbol</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.html#VALmatch_">match_</a> [<a href="TopDown.S.html">TopDown.S</a>]</td>
<td><div class="info">
<p><code class="code">match_ a sa b sb</code> matches the pattern <code class="code">a</code> in scope <code class="code">sa</code> with term
        <code class="code">b</code> in scope <code class="code">sb</code>.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.C.html#VALmax_var">max_var</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALmax_var">max_var</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td><div class="info">
<p>max var, or 0 if ground</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALmk">mk</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALmk_aggr">mk_aggr</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALmk_apply">mk_apply</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALmk_apply_l">mk_apply_l</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.C.html#VALmk_clause">mk_clause</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALmk_clause">mk_clause</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Create a clause from a conclusion and a list of premises</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.T.html#VALmk_const">mk_const</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALmk_const">mk_const</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.C.html#VALmk_fact">mk_fact</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALmk_literal">mk_literal</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Helper to build a literal.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALmk_neg">mk_neg</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALmk_pos">mk_pos</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALmk_var">mk_var</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALmk_var">mk_var</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="Default.html#VALmk_vartbl">mk_vartbl</a> [<a href="Default.html">Default</a>]</td>
<td></td></tr>
<tr><td align="left"><div>N</div></td></tr>
<tr><td><a href="CamlInterface.RelList.html#VALname">name</a> [<a href="CamlInterface.RelList.html">CamlInterface.RelList</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALname">name</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALname">name</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALname">name</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td><div class="info">
<p>Name of the relation</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALnew_key">new_key</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td><div class="info">
<p>Create a new key.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.DB.html#VALnum_clauses">num_clauses</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALnum_facts">num_facts</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td align="left"><div>O</div></td></tr>
<tr><td><a href="CamlInterface.html#VALof_int">of_int</a> [<a href="CamlInterface.html">CamlInterface</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSABLE_CONST.html#VALof_int">of_int</a> [<a href="TopDown.PARSABLE_CONST.html">TopDown.PARSABLE_CONST</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALof_soft_clause">of_soft_clause</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALof_soft_lit">of_soft_lit</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.html#VALof_string">of_string</a> [<a href="CamlInterface.html">CamlInterface</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSABLE_CONST.html#VALof_string">of_string</a> [<a href="TopDown.PARSABLE_CONST.html">TopDown.PARSABLE_CONST</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.CONST.html#VALof_string">of_string</a> [<a href="TopDown.CONST.html">TopDown.CONST</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALopen_clause">open_clause</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Deconstruct a clause</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALopen_literal">open_literal</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Deconstruct a literal</p>

</div>
</td></tr>
<tr><td align="left"><div>P</div></td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALpack">pack</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.Univ.html#VALpack">pack</a> [<a href="BottomUp.Univ.html">BottomUp.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALpair">pair</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSE.html#VALparse_chan">parse_chan</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownParser.html#VALparse_clause">parse_clause</a> [<a href="TopDownParser.html">TopDownParser</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUpParser.html#VALparse_clause">parse_clause</a> [<a href="BottomUpParser.html">BottomUpParser</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownParser.html#VALparse_file">parse_file</a> [<a href="TopDownParser.html">TopDownParser</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUpParser.html#VALparse_file">parse_file</a> [<a href="BottomUpParser.html">BottomUpParser</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSE.html#VALparse_file">parse_file</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownParser.html#VALparse_literal">parse_literal</a> [<a href="TopDownParser.html">TopDownParser</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUpParser.html#VALparse_literal">parse_literal</a> [<a href="BottomUpParser.html">BottomUpParser</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownParser.html#VALparse_literals">parse_literals</a> [<a href="TopDownParser.html">TopDownParser</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUpParser.html#VALparse_literals">parse_literals</a> [<a href="BottomUpParser.html">BottomUpParser</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownParser.html#VALparse_query">parse_query</a> [<a href="TopDownParser.html">TopDownParser</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUpParser.html#VALparse_query">parse_query</a> [<a href="BottomUpParser.html">BottomUpParser</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSE.html#VALparse_string">parse_string</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownParser.html#VALparse_term">parse_term</a> [<a href="TopDownParser.html">TopDownParser</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.C.html#VALpp">pp</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALpp">pp</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALpp">pp</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALpp_clause">pp_clause</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Pretty print the clause</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALpp_literal">pp_literal</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td><div class="info">
<p>Pretty print the literal</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.Query.html#VALpp_plan">pp_plan</a> [<a href="BottomUp.S.Query.html">BottomUp.S.Query</a>]</td>
<td><div class="info">
<p>Print query plan</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.html#VALpp_term">pp_term</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALpp_tuple">pp_tuple</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALprint">print</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownAst.html#VALprint_error">print_error</a> [<a href="TopDownAst.html">TopDownAst</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownLexer.html#VALprint_location">print_location</a> [<a href="TopDownLexer.html">TopDownLexer</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUpLexer.html#VALprint_location">print_location</a> [<a href="BottomUpLexer.html">BottomUpLexer</a>]</td>
<td></td></tr>
<tr><td align="left"><div>Q</div></td></tr>
<tr><td><a href="BottomUp.S.html#VALquantify1">quantify1</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALquantify2">quantify2</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALquantify3">quantify3</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALquantify4">quantify4</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.S.html#VALquantifyn">quantifyn</a> [<a href="BottomUp.S.html">BottomUp.S</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.CONST.html#VALquery">query</a> [<a href="TopDown.CONST.html">TopDown.CONST</a>]</td>
<td><div class="info">
<p>Special symbol, that will never occur in any user-defined
        clause or term.</p>

</div>
</td></tr>
<tr><td><a href="Default.html#VALquery_of_ast">query_of_ast</a> [<a href="Default.html">Default</a>]</td>
<td></td></tr>
<tr><td align="left"><div>R</div></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALreflexive">reflexive</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td><div class="info">
<p><code class="code">reflexive db r</code> makes <code class="code">r</code> reflexive in <code class="code">db</code>, ie for all <code class="code">X</code>,
        <code class="code">r(X,X)</code> holds in <code class="code">db</code>.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Index.html#VALremove">remove</a> [<a href="TopDown.S.Index.html">TopDown.S.Index</a>]</td>
<td><div class="info">
<p>Remove the term-&gt;data binding.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALrename">rename</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td><div class="info">
<p>Rename the given variable into a variable that is unique
          within variables known to the given <code class="code">renaming</code></p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Subst.html#VALreset_renaming">reset_renaming</a> [<a href="TopDown.S.Subst.html">TopDown.S.Subst</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Rewriting.html#VALrewrite">rewrite</a> [<a href="TopDown.S.Rewriting.html">TopDown.S.Rewriting</a>]</td>
<td><div class="info">
<p>Normalize the term recursively.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.Rewriting.html#VALrewrite_root">rewrite_root</a> [<a href="TopDown.S.Rewriting.html">TopDown.S.Rewriting</a>]</td>
<td><div class="info">
<p>rewrite the term, but only its root.</p>

</div>
</td></tr>
<tr><td align="left"><div>S</div></td></tr>
<tr><td><a href="TopDown.S.html#VALset_debug">set_debug</a> [<a href="TopDown.S.html">TopDown.S</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.Default.html#VALsetup_default">setup_default</a> [<a href="TopDown.Default.html">TopDown.Default</a>]</td>
<td><div class="info">
<p>Load the default interpreters and builtin functions into the DB</p>

</div>
</td></tr>
<tr><td><a href="TopDownUnix.S.html#VALsetup_handlers">setup_handlers</a> [<a href="TopDownUnix.S.html">TopDownUnix.S</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.DB.html#VALsize">size</a> [<a href="TopDown.S.DB.html">TopDown.S.DB</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Index.html#VALsize">size</a> [<a href="TopDown.S.Index.html">TopDown.S.Index</a>]</td>
<td><div class="info">
<p>Number of bindings</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALstring">string</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALsubset">subset</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALsubset">subset</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td><div class="info">
<p><code class="code">subset db r1 r2</code> adds to <code class="code">db</code> the axiom that <code class="code">r2(X,Y) :- r1(X,Y)</code>;
        in other words, <code class="code">r1</code> is a subset of <code class="code">r2</code> as a relation</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALsubset">subset</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td><div class="info">
<p><code class="code">subset db r1 r2</code> adds to <code class="code">db</code> the axiom that <code class="code">r2(X) :- r1(X)</code>;
        in other words, <code class="code">r1</code> is a subset of <code class="code">r2</code> as a relation</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALsymmetry">symmetry</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td><div class="info">
<p>Axiom for symmetry (ie "r(X,Y) &lt;=&gt; r(Y,X)") added to the DB</p>

</div>
</td></tr>
<tr><td align="left"><div>T</div></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALtc_of">tc_of</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td><div class="info">
<p><code class="code">tc_of db ~tc r</code> adds to <code class="code">db</code> axioms that make the relation <code class="code">tc</code>
        the transitive closure of the relation <code class="code">r</code>.</p>

</div>
</td></tr>
<tr><td><a href="TopDown.PARSE.html#VALterm_of_ast">term_of_ast</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.PARSE.html#VALterm_of_string">term_of_string</a> [<a href="TopDown.PARSE.html">TopDown.PARSE</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="TopDown.S.Rewriting.html#VALto_list">to_list</a> [<a href="TopDown.S.Rewriting.html">TopDown.S.Rewriting</a>]</td>
<td><div class="info">
<p>List of rules</p>

</div>
</td></tr>
<tr><td><a href="BottomUp.S.Query.html#VALto_list">to_list</a> [<a href="BottomUp.S.Query.html">BottomUp.S.Query</a>]</td>
<td><div class="info">
<p>Convert to a list</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Rel3.html#VALto_string">to_string</a> [<a href="CamlInterface.Rel3.html">CamlInterface.Rel3</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALto_string">to_string</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel1.html#VALto_string">to_string</a> [<a href="CamlInterface.Rel1.html">CamlInterface.Rel1</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.C.html#VALto_string">to_string</a> [<a href="TopDown.S.C.html">TopDown.S.C</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALto_string">to_string</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.T.html#VALto_string">to_string</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.CONST.html#VALto_string">to_string</a> [<a href="TopDown.CONST.html">TopDown.CONST</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.SymbolType.html#VALto_string">to_string</a> [<a href="BottomUp.SymbolType.html">BottomUp.SymbolType</a>]</td>
<td></td></tr>
<tr><td><a href="TopDown.S.Lit.html#VALto_term">to_term</a> [<a href="TopDown.S.Lit.html">TopDown.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="TopDownLexer.html#VALtoken">token</a> [<a href="TopDownLexer.html">TopDownLexer</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUpLexer.html#VALtoken">token</a> [<a href="BottomUpLexer.html">BottomUpLexer</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Rel2.html#VALtransitive">transitive</a> [<a href="CamlInterface.Rel2.html">CamlInterface.Rel2</a>]</td>
<td><div class="info">
<p>Axioms for transitivity are added to the DB</p>

</div>
</td></tr>
<tr><td align="left"><div>U</div></td></tr>
<tr><td><a href="TopDown.S.Index.html#VALunify">unify</a> [<a href="TopDown.S.Index.html">TopDown.S.Index</a>]</td>
<td><div class="info">
<p>Retrieve data associated with terms that unify with the given
          query term</p>

</div>
</td></tr>
<tr><td><a href="TopDown.S.html#VALunify">unify</a> [<a href="TopDown.S.html">TopDown.S</a>]</td>
<td><div class="info">
<p>Unify the two terms.</p>

</div>
</td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALunit">unit</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="CamlInterface.Univ.html#VALunpack">unpack</a> [<a href="CamlInterface.Univ.html">CamlInterface.Univ</a>]</td>
<td></td></tr>
<tr><td><a href="BottomUp.Univ.html#VALunpack">unpack</a> [<a href="BottomUp.Univ.html">BottomUp.Univ</a>]</td>
<td></td></tr>
<tr><td align="left"><div>V</div></td></tr>
<tr><td><a href="TopDown.S.T.html#VALvars">vars</a> [<a href="TopDown.S.T.html">TopDown.S.T</a>]</td>
<td></td></tr>
<tr><td><a href="Version.html#VALversion">version</a> [<a href="Version.html">Version</a>]</td>
<td></td></tr>
</table>
</body>
</html>