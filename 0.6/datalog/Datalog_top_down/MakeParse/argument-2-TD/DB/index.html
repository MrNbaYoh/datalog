<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>DB (datalog.Datalog_top_down.MakeParse.2-TD.DB)</title><link rel="stylesheet" href="../../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">datalog</a> &#x00BB; <a href="../../../index.html">Datalog_top_down</a> &#x00BB; <a href="../../index.html">MakeParse</a> &#x00BB; <a href="../index.html">2-TD</a> &#x00BB; DB</nav><h1>Module <code>2-TD.DB</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>A database is a repository for Datalog clauses.</p></dd></dl><dl><dt class="spec type" id="type-interpreter"><a href="#type-interpreter" class="anchor"></a><code><span class="keyword">type</span> interpreter</code><code> = <a href="../T/index.html#type-t">T.t</a> <span>&#45;&gt;</span> <a href="../C/index.html#type-t">C.t</a> list</code></dt><dd><p>Interpreted predicate. It takes terms which have a given symbol as head, and return a list of (safe) clauses that have the same symbol as head, and should unify with the query term.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;parent:<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val</span> clear : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_fact"><a href="#val-add_fact" class="anchor"></a><code><span class="keyword">val</span> add_fact : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../T/index.html#type-t">T.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_facts"><a href="#val-add_facts" class="anchor"></a><code><span class="keyword">val</span> add_facts : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../T/index.html#type-t">T.t</a> list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_clause"><a href="#val-add_clause" class="anchor"></a><code><span class="keyword">val</span> add_clause : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_clauses"><a href="#val-add_clauses" class="anchor"></a><code><span class="keyword">val</span> add_clauses : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../C/index.html#type-t">C.t</a> list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-interpret"><a href="#val-interpret" class="anchor"></a><code><span class="keyword">val</span> interpret : ?&#8288;help:string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-const">const</a> <span>&#45;&gt;</span> <a href="index.html#type-interpreter">interpreter</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add an interpreter for the given constant. Goals that start with this constant will be given to all registered interpreters, all of which can add new clauses. The returned clauses must have the constant as head symbol.</p></dd></dl><dl><dt class="spec value" id="val-interpret_list"><a href="#val-interpret_list" class="anchor"></a><code><span class="keyword">val</span> interpret_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="../index.html#type-const">const</a> * string * <a href="index.html#type-interpreter">interpreter</a>) list <span>&#45;&gt;</span> unit</code></dt><dd><p>Add several interpreters, with their documentation</p></dd></dl><dl><dt class="spec value" id="val-is_interpreted"><a href="#val-is_interpreted" class="anchor"></a><code><span class="keyword">val</span> is_interpreted : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-const">const</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the constant interpreted by some OCaml code?</p></dd></dl><dl><dt class="spec value" id="val-add_builtin"><a href="#val-add_builtin" class="anchor"></a><code><span class="keyword">val</span> add_builtin : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Const/index.html#type-t">Const.t</a> <span>&#45;&gt;</span> <a href="../BuiltinFun/index.html#type-t">BuiltinFun.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a builtin fun</p></dd></dl><dl><dt class="spec value" id="val-builtin_funs"><a href="#val-builtin_funs" class="anchor"></a><code><span class="keyword">val</span> builtin_funs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../BuiltinFun/index.html#type-map">BuiltinFun.map</a></code></dt><dt class="spec value" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span class="keyword">val</span> eval : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../T/index.html#type-t">T.t</a> <span>&#45;&gt;</span> <a href="../T/index.html#type-t">T.t</a></code></dt><dd><p>Evaluate the given term at root</p></dd></dl><dl><dt class="spec value" id="val-help"><a href="#val-help" class="anchor"></a><code><span class="keyword">val</span> help : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string list</code></dt><dd><p>Help messages for interpreted predicates</p></dd></dl><dl><dt class="spec value" id="val-num_facts"><a href="#val-num_facts" class="anchor"></a><code><span class="keyword">val</span> num_facts : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-num_clauses"><a href="#val-num_clauses" class="anchor"></a><code><span class="keyword">val</span> num_clauses : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-find_facts"><a href="#val-find_facts" class="anchor"></a><code><span class="keyword">val</span> find_facts : ?&#8288;oc:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-scope">scope</a> <span>&#45;&gt;</span> <a href="../T/index.html#type-t">T.t</a> <span>&#45;&gt;</span> <a href="../index.html#type-scope">scope</a> <span>&#45;&gt;</span> (<a href="../T/index.html#type-t">T.t</a> <span>&#45;&gt;</span> <a href="../Subst/index.html#type-t">Subst.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>find facts unifying with the given term, and give them along with the unifier, to the callback</p></dd></dl><dl><dt class="spec value" id="val-find_clauses_head"><a href="#val-find_clauses_head" class="anchor"></a><code><span class="keyword">val</span> find_clauses_head : ?&#8288;oc:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-scope">scope</a> <span>&#45;&gt;</span> <a href="../T/index.html#type-t">T.t</a> <span>&#45;&gt;</span> <a href="../index.html#type-scope">scope</a> <span>&#45;&gt;</span> (<a href="../C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <a href="../Subst/index.html#type-t">Subst.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>find clauses whose head unifies with the given term, and give them along with the unifier, to the callback</p></dd></dl><dl><dt class="spec value" id="val-find_interpretation"><a href="#val-find_interpretation" class="anchor"></a><code><span class="keyword">val</span> find_interpretation : ?&#8288;oc:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-scope">scope</a> <span>&#45;&gt;</span> <a href="../T/index.html#type-t">T.t</a> <span>&#45;&gt;</span> <a href="../index.html#type-scope">scope</a> <span>&#45;&gt;</span> (<a href="../C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <a href="../Subst/index.html#type-t">Subst.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Given an interpreted goal, try all interpreters on it, and match the query against their heads. Returns clauses whose head unifies with the goal, along with the substitution.</p></dd></dl></div></body></html>